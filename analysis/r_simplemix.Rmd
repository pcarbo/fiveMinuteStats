---
title: Generate data from a simple genetic mixture model
author: 
  name: Matthew Stephens
  affiliation: University of Chicago
date: January 7, 2026
output:
  pdf_document:
    keep_tex: false
    latex_engine: pdflatex
    template: readable.tex
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
spacing: single
graphics: yes
endnote: no
---

See [here][pdf_version] for a PDF version of this vignette.

```{r knitr-opts, include=FALSE}
knitr::opts_chunk$set(comment = "#",collapse = TRUE,fig.align = "center")
```

Introduction
============

This vignette is an "ice breaker" to motivate learning and statistical
inference centered around genetic mixtures.

You don't need to know what a mixture model is to understand this. But
if you want to know more about mixture models in general you might
read [this introduction to mixture models][intro_to_mixture_models].

Simulating haploid data for a single population
-----------------------------------------------

First we consider simulating genotype data for $n$ haploid individuals
at $R$ independent biallelic loci (positions along the genome)
sampled from a population.

The term "haploid" means that each individual has only one copy of
their genome. (Most animals are "diploid", which means they have two
copies of their genome â€” one inherited from the mother and the other
inherited from the father. However, focussing on haploid individuals
makes the ideas and code easier to follow. Once you understand the
haploid case it is not too hard to extend the ideas to the diploid
case.)

The term "biallelic" means that the loci have two possible alleles
(types), which for convenience we will label 0 and 1.

Under these assumptions, the genotype for each individual is simply a
sequence of zeros and ones. The probability of seeing a 0 vs. a 1 at
each locus is determined by the "allele frequencies" at each locus,
which we will specify by a vector $p$. Specifically, $p_r$ specifies
the frequency of the 1 allele at locus $r$.

The following code simulates from this model.

```{r r-haploid-genotypes}
#' @param n The number of samples.
#' @param p A vector of allele frequencies for R loci.
#' @return An n x R matrix of haploid genotypes.
r_haploid_genotypes <- function (n, p) {
  R <- length(p)
  x <- matrix(0,n,R)
  for (i in 1:n)
    x[i,] <- rbinom(R,rep(1,R),p)
  return(x)
}
```

Example
-------

To illustrate this function, we simulate a small example dataset 
containing 20 haploid individuals at 9 loci. The frequencies of the 1
allele at the loci are increasing from 0.1 at the first locus to 0.9
at the ninth locus. (The pattern is not supposed to be realistic, it
is just to help illustrate the idea.)

```{r r-haploid-genotypes-demo}
set.seed(123)
p <- seq(0.1,0.9,length.out = 9)
x <- r_haploid_genotypes(20,p)
p
x 
```

As you can see, the 1 allele is rarer at the earlier loci, whereas
the 0 allele is rarer at the later loci.

Simulating haploid data from a mixture of two populations
=========================================================

Now suppose we sample from a group of individuals formed by
mixing together the individuals from two different populations.
This is an example of a "mixture model".

For simplicity, we will assume the two different populations
are mixed in equal proportions. That is, the "mixture proportions"
are 0.5 and 0.5.

The following function generates data from such a model. The allele
frequencies for the two populations must be specified in a matrix,
${\bf P}$, whose first row contains the allele frequencies for
population 1 and second row is the allele frequencies for population
2. (So element $p_{kr}$ is the frequency of the 1 alleles in
population $k$ at locus $r$.)  For each individual $i$, it randomly
samples the population $z_i = k$ to be 1 or 2, and then uses the
`r_haploid_genotypes` function to generate the genotypes from that
population.

```{r r-simplemix}
#' @param n The number of samples.
#' @param P A 2 x R matrix of allele frequencies.
#' @return A list containing a matrix of genotypes (x) and
#'   the populations of origin (z).
r_simplemix <- function (n, P) {
  R <- ncol(P)
  z <- rep(0,n)
  x <- matrix(0,n,R)
  for (i in 1:n) {
    z[i]  <- sample(2,1,prob = c(0.5,0.5))
	k     <- z[i]
    x[i,] <- r_haploid_genotypes(1,P[k,])
  }
  return(list(x = x,z = z))
}
```

Example
-------

In this example, we sample 20 individuals: in one population, the
frequencies are as above, whereas in the second population they are
reversed ($1 - p$). Again, this is not at all realistic, but intended
to illustrate the ideas.

```{r r-simplemix-demo}
set.seed(123)
P <- rbind(p,1 - p,deparse.level = 0)
print(P)
sim <- r_simplemix(20,P)
```

Here are the results of the simulation:

```{r r-simplemix-demo-output}
colnames(sim$x) <- paste0("r",1:9)
cbind(z = sim$z,sim$x)
```

If you look carefully, you should see that individuals from population
1 tend to have more 1 alleles in the later loci, whereas individuals
from population 2 tend to have more 1 alleles in the earlier loci.
This is because of the way that the allele frequencies were set up in
the two populations. Of course, in real data the differences between
different populations will not usually show patterns like this! I
chose the patterns so you can see them by eye.

Inference problems
==================

These types of data can help motivate a number of statistical
inference problems, including:
 
1. Given the allele frequencies ${\bf P}$ and the genotypes ${\bf X}$,
how might you infer the populations of origin $z$? In the genetic
literature, this is sometimes called the "assignment problem"; more
generally, it is an example of a "classification problem".

2. Given the populations of origin $z$ and the genotypes ${\bf X}$, how
might you infer the population allele frequencies ${\bf P}$?

3. Given just the genotypes ${\bf X}$ how might you infer *both* $z$
and ${\bf P}$? This is an example of a "clustering problem".

Exercises
=========

Here are some things you might like to try:

1. Modify the `r_simplemix` function to allow the mixture proportions
to be specified as an input argument, rather than fixed at
$(0.5, 0.5)$. You could do this by adding a parameter "w" to the
function that specifies the proportions to use ("w" is short for
"weights").

2. Write a function `posterior_prob_assignment(x,P,w)` to compute the
posterior probability that each individual came from each population,
given the genotypes "x", the allele frequencies "P" and the mixture
proportions "w".  Apply your function to the data you simulated.

3. Write a function `posterior_param_allele_frequencies(x,z,a)` to
compute the parameters of the Beta posterior in each population at
each locus.  Here, "a" is a vector of length 2 giving the parameters
of the Beta prior for $p_{kr}$; that is, the prior is $p_{kr} \sim
\mathrm{Beta}(a_1, a_2)$. Because the Beta distribution has two
parameters, there will be 2 parameters for each locus and for each
population. So the output of your function should be two $2 \times R$
matrices, or a $2 \times 2 \times R$ array.

Answer templates
================

Here are some answer templates for Exercises 2 and 3. You will need to
fill in the "add your code here" comments. (*Note:* some of these code
chunks have the option set `eval = FALSE` so that this document
compiles. You will have to remove this option if you want these chunks
to run on compilation.)

Exercise 2
----------

Function to compute the likelihood:

```{r likelihood}
#' @param p A vector of allele frequencies of length R.
#' @param x A vector of genotypes of length R.
#' @return The likelihood for the allele frequences (p) given the
#'   genotype data (x).
likelihood <- function (p, x)
  prod(p^x*(1-p)^(1-x))
```

Function to "normalize" a vector:

```{r normalize}
#' @param x A vector.
#' @return The normalized vector in which its elements sum to 1.
normalize <- function (x)
  x/sum(x)
```

Function to compute the posterior assignment probabilities:

```{r posterior-prob-assignment}
#' @param x An n x R matrix of genotypes.
#' @param P A 2 x R matrix of allele frequencies.
#' @param w A vector of mixture proportions of length 2.
#' @return An n x 2 matrix of posterior assignment probabilities.
posterior_prob_assignment <- function (x, P, w) {
  n <- nrow(x)
  K <- 2
  post <- matrix(0,n,K)
  lik <- rep(0,K)
  for (i in 1:n) {
    for (k in 1:K) {
      # Add your code here.
    }
    # Add your code here.
  }
  return(post)
}
```

Once you have implemented this function, try running it on an example
data set, and compare the posterior assignment probabilities to the
true labels:

```{r posterior-prob-assignment-test, eval=FALSE}
set.seed(123)
sim <- r_simplemix(20,P)
posterior <- posterior_prob_assignment(sim$x,P,w = c(0.5,0.5))
plot(sim$z,posterior[,2],xlab = "true population",
     ylab = "posterior prob for population 2")
```

Exercise 3
----------

```{r, eval=FALSE}
#' Compute the posterior parameters for allele frequencies given genotypes 
#' and population labels
#' @param x an n by R matrix of genotypes
#' @param z an n vector of population assignments
#' @param a a 2-vector of prior parameters
posterior_param_allele_frequencies=function(x,z,a){
 K = 2
 R = ncol(x)
 post_param = array(dim=c(2,K,R))
 for(k in 1:K){
   for(r in 1:R){
     ...
   }
 }
 return(post_param)
}
```

Here we can run this on the example data:

```{r, eval=FALSE}
set.seed(123)
sim = r_simplemix(n=20,P)
posterior_param = posterior_param_allele_frequencies(sim$x,sim$z,a = c(1,1))
posterior_param[,1,] # these should be the posterior parameters for population 1
posterior_param[,2,] # these should be the posterior parameters for population 2
```

[pdf_version]: https://github.com/pcarbo/fiveMinuteStats/blob/master/docs/r_simplemix.pdf
[intro_to_mixture_models]: https://pcarbo.github.io/fiveMinuteStats/intro_to_mixture_models.html
